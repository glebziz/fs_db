// Code generated by MockGen. DO NOT EDIT.
// Source: service.go
//
// Generated by this command:
//
//	mockgen -source service.go -destination mocks/mocks.go -typed true
//
// Package mock_store is a generated GoMock package.
package mock_store

import (
	context "context"
	io "io"
	reflect "reflect"

	model "github.com/glebziz/fs_db/internal/model"
	gomock "go.uber.org/mock/gomock"
)

// MockstoreUseCase is a mock of storeUseCase interface.
type MockstoreUseCase struct {
	ctrl     *gomock.Controller
	recorder *MockstoreUseCaseMockRecorder
}

// MockstoreUseCaseMockRecorder is the mock recorder for MockstoreUseCase.
type MockstoreUseCaseMockRecorder struct {
	mock *MockstoreUseCase
}

// NewMockstoreUseCase creates a new mock instance.
func NewMockstoreUseCase(ctrl *gomock.Controller) *MockstoreUseCase {
	mock := &MockstoreUseCase{ctrl: ctrl}
	mock.recorder = &MockstoreUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockstoreUseCase) EXPECT() *MockstoreUseCaseMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockstoreUseCase) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockstoreUseCaseMockRecorder) Delete(ctx, key any) *storeUseCaseDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockstoreUseCase)(nil).Delete), ctx, key)
	return &storeUseCaseDeleteCall{Call: call}
}

// storeUseCaseDeleteCall wrap *gomock.Call
type storeUseCaseDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *storeUseCaseDeleteCall) Return(arg0 error) *storeUseCaseDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *storeUseCaseDeleteCall) Do(f func(context.Context, string) error) *storeUseCaseDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *storeUseCaseDeleteCall) DoAndReturn(f func(context.Context, string) error) *storeUseCaseDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockstoreUseCase) Get(ctx context.Context, key string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockstoreUseCaseMockRecorder) Get(ctx, key any) *storeUseCaseGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockstoreUseCase)(nil).Get), ctx, key)
	return &storeUseCaseGetCall{Call: call}
}

// storeUseCaseGetCall wrap *gomock.Call
type storeUseCaseGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *storeUseCaseGetCall) Return(arg0 io.ReadCloser, arg1 error) *storeUseCaseGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *storeUseCaseGetCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *storeUseCaseGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *storeUseCaseGetCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *storeUseCaseGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// GetKeys mocks base method.
func (m *MockstoreUseCase) GetKeys(ctx context.Context) ([]string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetKeys", ctx)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetKeys indicates an expected call of GetKeys.
func (mr *MockstoreUseCaseMockRecorder) GetKeys(ctx any) *storeUseCaseGetKeysCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetKeys", reflect.TypeOf((*MockstoreUseCase)(nil).GetKeys), ctx)
	return &storeUseCaseGetKeysCall{Call: call}
}

// storeUseCaseGetKeysCall wrap *gomock.Call
type storeUseCaseGetKeysCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *storeUseCaseGetKeysCall) Return(arg0 []string, arg1 error) *storeUseCaseGetKeysCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *storeUseCaseGetKeysCall) Do(f func(context.Context) ([]string, error)) *storeUseCaseGetKeysCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *storeUseCaseGetKeysCall) DoAndReturn(f func(context.Context) ([]string, error)) *storeUseCaseGetKeysCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Set mocks base method.
func (m *MockstoreUseCase) Set(ctx context.Context, key string, content io.Reader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Set", ctx, key, content)
	ret0, _ := ret[0].(error)
	return ret0
}

// Set indicates an expected call of Set.
func (mr *MockstoreUseCaseMockRecorder) Set(ctx, key, content any) *storeUseCaseSetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Set", reflect.TypeOf((*MockstoreUseCase)(nil).Set), ctx, key, content)
	return &storeUseCaseSetCall{Call: call}
}

// storeUseCaseSetCall wrap *gomock.Call
type storeUseCaseSetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *storeUseCaseSetCall) Return(arg0 error) *storeUseCaseSetCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *storeUseCaseSetCall) Do(f func(context.Context, string, io.Reader) error) *storeUseCaseSetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *storeUseCaseSetCall) DoAndReturn(f func(context.Context, string, io.Reader) error) *storeUseCaseSetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxUseCase is a mock of txUseCase interface.
type MocktxUseCase struct {
	ctrl     *gomock.Controller
	recorder *MocktxUseCaseMockRecorder
}

// MocktxUseCaseMockRecorder is the mock recorder for MocktxUseCase.
type MocktxUseCaseMockRecorder struct {
	mock *MocktxUseCase
}

// NewMocktxUseCase creates a new mock instance.
func NewMocktxUseCase(ctrl *gomock.Controller) *MocktxUseCase {
	mock := &MocktxUseCase{ctrl: ctrl}
	mock.recorder = &MocktxUseCaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxUseCase) EXPECT() *MocktxUseCaseMockRecorder {
	return m.recorder
}

// Begin mocks base method.
func (m *MocktxUseCase) Begin(ctx context.Context, isoLevel model.TxIsoLevel) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Begin", ctx, isoLevel)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Begin indicates an expected call of Begin.
func (mr *MocktxUseCaseMockRecorder) Begin(ctx, isoLevel any) *txUseCaseBeginCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Begin", reflect.TypeOf((*MocktxUseCase)(nil).Begin), ctx, isoLevel)
	return &txUseCaseBeginCall{Call: call}
}

// txUseCaseBeginCall wrap *gomock.Call
type txUseCaseBeginCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txUseCaseBeginCall) Return(arg0 string, arg1 error) *txUseCaseBeginCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txUseCaseBeginCall) Do(f func(context.Context, model.TxIsoLevel) (string, error)) *txUseCaseBeginCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txUseCaseBeginCall) DoAndReturn(f func(context.Context, model.TxIsoLevel) (string, error)) *txUseCaseBeginCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Commit mocks base method.
func (m *MocktxUseCase) Commit(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Commit", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Commit indicates an expected call of Commit.
func (mr *MocktxUseCaseMockRecorder) Commit(ctx any) *txUseCaseCommitCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Commit", reflect.TypeOf((*MocktxUseCase)(nil).Commit), ctx)
	return &txUseCaseCommitCall{Call: call}
}

// txUseCaseCommitCall wrap *gomock.Call
type txUseCaseCommitCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txUseCaseCommitCall) Return(arg0 error) *txUseCaseCommitCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txUseCaseCommitCall) Do(f func(context.Context) error) *txUseCaseCommitCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txUseCaseCommitCall) DoAndReturn(f func(context.Context) error) *txUseCaseCommitCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Rollback mocks base method.
func (m *MocktxUseCase) Rollback(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rollback", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Rollback indicates an expected call of Rollback.
func (mr *MocktxUseCaseMockRecorder) Rollback(ctx any) *txUseCaseRollbackCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rollback", reflect.TypeOf((*MocktxUseCase)(nil).Rollback), ctx)
	return &txUseCaseRollbackCall{Call: call}
}

// txUseCaseRollbackCall wrap *gomock.Call
type txUseCaseRollbackCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txUseCaseRollbackCall) Return(arg0 error) *txUseCaseRollbackCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txUseCaseRollbackCall) Do(f func(context.Context) error) *txUseCaseRollbackCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txUseCaseRollbackCall) DoAndReturn(f func(context.Context) error) *txUseCaseRollbackCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
