// Code generated by MockGen. DO NOT EDIT.
// Source: usecase.go
//
// Generated by this command:
//
//	mockgen -source usecase.go -destination mocks/mocks.go -typed true
//
// Package mock_store is a generated GoMock package.
package mock_store

import (
	context "context"
	io "io"
	reflect "reflect"

	model "github.com/glebziz/fs_db/internal/model"
	gomock "go.uber.org/mock/gomock"
)

// MockdirUsecase is a mock of dirUsecase interface.
type MockdirUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockdirUsecaseMockRecorder
}

// MockdirUsecaseMockRecorder is the mock recorder for MockdirUsecase.
type MockdirUsecaseMockRecorder struct {
	mock *MockdirUsecase
}

// NewMockdirUsecase creates a new mock instance.
func NewMockdirUsecase(ctrl *gomock.Controller) *MockdirUsecase {
	mock := &MockdirUsecase{ctrl: ctrl}
	mock.recorder = &MockdirUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockdirUsecase) EXPECT() *MockdirUsecaseMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockdirUsecase) Get(ctx context.Context) (model.Dirs, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx)
	ret0, _ := ret[0].(model.Dirs)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockdirUsecaseMockRecorder) Get(ctx any) *dirUsecaseGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockdirUsecase)(nil).Get), ctx)
	return &dirUsecaseGetCall{Call: call}
}

// dirUsecaseGetCall wrap *gomock.Call
type dirUsecaseGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *dirUsecaseGetCall) Return(arg0 model.Dirs, arg1 error) *dirUsecaseGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *dirUsecaseGetCall) Do(f func(context.Context) (model.Dirs, error)) *dirUsecaseGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *dirUsecaseGetCall) DoAndReturn(f func(context.Context) (model.Dirs, error)) *dirUsecaseGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockcontentRepository is a mock of contentRepository interface.
type MockcontentRepository struct {
	ctrl     *gomock.Controller
	recorder *MockcontentRepositoryMockRecorder
}

// MockcontentRepositoryMockRecorder is the mock recorder for MockcontentRepository.
type MockcontentRepositoryMockRecorder struct {
	mock *MockcontentRepository
}

// NewMockcontentRepository creates a new mock instance.
func NewMockcontentRepository(ctrl *gomock.Controller) *MockcontentRepository {
	mock := &MockcontentRepository{ctrl: ctrl}
	mock.recorder = &MockcontentRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcontentRepository) EXPECT() *MockcontentRepositoryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockcontentRepository) Get(ctx context.Context, path string) (io.ReadCloser, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, path)
	ret0, _ := ret[0].(io.ReadCloser)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockcontentRepositoryMockRecorder) Get(ctx, path any) *contentRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockcontentRepository)(nil).Get), ctx, path)
	return &contentRepositoryGetCall{Call: call}
}

// contentRepositoryGetCall wrap *gomock.Call
type contentRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentRepositoryGetCall) Return(arg0 io.ReadCloser, arg1 error) *contentRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentRepositoryGetCall) Do(f func(context.Context, string) (io.ReadCloser, error)) *contentRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentRepositoryGetCall) DoAndReturn(f func(context.Context, string) (io.ReadCloser, error)) *contentRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockcontentRepository) Store(ctx context.Context, path string, content io.Reader) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, path, content)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockcontentRepositoryMockRecorder) Store(ctx, path, content any) *contentRepositoryStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockcontentRepository)(nil).Store), ctx, path, content)
	return &contentRepositoryStoreCall{Call: call}
}

// contentRepositoryStoreCall wrap *gomock.Call
type contentRepositoryStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentRepositoryStoreCall) Return(arg0 error) *contentRepositoryStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentRepositoryStoreCall) Do(f func(context.Context, string, io.Reader) error) *contentRepositoryStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentRepositoryStoreCall) DoAndReturn(f func(context.Context, string, io.Reader) error) *contentRepositoryStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockcontentFileRepository is a mock of contentFileRepository interface.
type MockcontentFileRepository struct {
	ctrl     *gomock.Controller
	recorder *MockcontentFileRepositoryMockRecorder
}

// MockcontentFileRepositoryMockRecorder is the mock recorder for MockcontentFileRepository.
type MockcontentFileRepositoryMockRecorder struct {
	mock *MockcontentFileRepository
}

// NewMockcontentFileRepository creates a new mock instance.
func NewMockcontentFileRepository(ctrl *gomock.Controller) *MockcontentFileRepository {
	mock := &MockcontentFileRepository{ctrl: ctrl}
	mock.recorder = &MockcontentFileRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcontentFileRepository) EXPECT() *MockcontentFileRepositoryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MockcontentFileRepository) Get(ctx context.Context, id string) (*model.ContentFile, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, id)
	ret0, _ := ret[0].(*model.ContentFile)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockcontentFileRepositoryMockRecorder) Get(ctx, id any) *contentFileRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockcontentFileRepository)(nil).Get), ctx, id)
	return &contentFileRepositoryGetCall{Call: call}
}

// contentFileRepositoryGetCall wrap *gomock.Call
type contentFileRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentFileRepositoryGetCall) Return(arg0 *model.ContentFile, arg1 error) *contentFileRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentFileRepositoryGetCall) Do(f func(context.Context, string) (*model.ContentFile, error)) *contentFileRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentFileRepositoryGetCall) DoAndReturn(f func(context.Context, string) (*model.ContentFile, error)) *contentFileRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockcontentFileRepository) Store(ctx context.Context, file model.ContentFile) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, file)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockcontentFileRepositoryMockRecorder) Store(ctx, file any) *contentFileRepositoryStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockcontentFileRepository)(nil).Store), ctx, file)
	return &contentFileRepositoryStoreCall{Call: call}
}

// contentFileRepositoryStoreCall wrap *gomock.Call
type contentFileRepositoryStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentFileRepositoryStoreCall) Return(arg0 error) *contentFileRepositoryStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentFileRepositoryStoreCall) Do(f func(context.Context, model.ContentFile) error) *contentFileRepositoryStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentFileRepositoryStoreCall) DoAndReturn(f func(context.Context, model.ContentFile) error) *contentFileRepositoryStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockfileRepository is a mock of fileRepository interface.
type MockfileRepository struct {
	ctrl     *gomock.Controller
	recorder *MockfileRepositoryMockRecorder
}

// MockfileRepositoryMockRecorder is the mock recorder for MockfileRepository.
type MockfileRepositoryMockRecorder struct {
	mock *MockfileRepository
}

// NewMockfileRepository creates a new mock instance.
func NewMockfileRepository(ctrl *gomock.Controller) *MockfileRepository {
	mock := &MockfileRepository{ctrl: ctrl}
	mock.recorder = &MockfileRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockfileRepository) EXPECT() *MockfileRepositoryMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockfileRepository) Delete(ctx context.Context, txId, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, txId, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockfileRepositoryMockRecorder) Delete(ctx, txId, key any) *fileRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockfileRepository)(nil).Delete), ctx, txId, key)
	return &fileRepositoryDeleteCall{Call: call}
}

// fileRepositoryDeleteCall wrap *gomock.Call
type fileRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryDeleteCall) Return(arg0 error) *fileRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryDeleteCall) Do(f func(context.Context, string, string) error) *fileRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryDeleteCall) DoAndReturn(f func(context.Context, string, string) error) *fileRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockfileRepository) Get(ctx context.Context, txId, key string, filter *model.FileFilter) (*model.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, txId, key, filter)
	ret0, _ := ret[0].(*model.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockfileRepositoryMockRecorder) Get(ctx, txId, key, filter any) *fileRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockfileRepository)(nil).Get), ctx, txId, key, filter)
	return &fileRepositoryGetCall{Call: call}
}

// fileRepositoryGetCall wrap *gomock.Call
type fileRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryGetCall) Return(arg0 *model.File, arg1 error) *fileRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryGetCall) Do(f func(context.Context, string, string, *model.FileFilter) (*model.File, error)) *fileRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryGetCall) DoAndReturn(f func(context.Context, string, string, *model.FileFilter) (*model.File, error)) *fileRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockfileRepository) Store(ctx context.Context, txId string, file model.File) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, txId, file)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockfileRepositoryMockRecorder) Store(ctx, txId, file any) *fileRepositoryStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockfileRepository)(nil).Store), ctx, txId, file)
	return &fileRepositoryStoreCall{Call: call}
}

// fileRepositoryStoreCall wrap *gomock.Call
type fileRepositoryStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryStoreCall) Return(arg0 error) *fileRepositoryStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryStoreCall) Do(f func(context.Context, string, model.File) error) *fileRepositoryStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryStoreCall) DoAndReturn(f func(context.Context, string, model.File) error) *fileRepositoryStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MocktxRepository is a mock of txRepository interface.
type MocktxRepository struct {
	ctrl     *gomock.Controller
	recorder *MocktxRepositoryMockRecorder
}

// MocktxRepositoryMockRecorder is the mock recorder for MocktxRepository.
type MocktxRepositoryMockRecorder struct {
	mock *MocktxRepository
}

// NewMocktxRepository creates a new mock instance.
func NewMocktxRepository(ctrl *gomock.Controller) *MocktxRepository {
	mock := &MocktxRepository{ctrl: ctrl}
	mock.recorder = &MocktxRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MocktxRepository) EXPECT() *MocktxRepositoryMockRecorder {
	return m.recorder
}

// Get mocks base method.
func (m *MocktxRepository) Get(ctx context.Context, id string) (*model.Transaction, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, id)
	ret0, _ := ret[0].(*model.Transaction)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MocktxRepositoryMockRecorder) Get(ctx, id any) *txRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MocktxRepository)(nil).Get), ctx, id)
	return &txRepositoryGetCall{Call: call}
}

// txRepositoryGetCall wrap *gomock.Call
type txRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *txRepositoryGetCall) Return(arg0 *model.Transaction, arg1 error) *txRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *txRepositoryGetCall) Do(f func(context.Context, string) (*model.Transaction, error)) *txRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *txRepositoryGetCall) DoAndReturn(f func(context.Context, string) (*model.Transaction, error)) *txRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockgenerator is a mock of generator interface.
type Mockgenerator struct {
	ctrl     *gomock.Controller
	recorder *MockgeneratorMockRecorder
}

// MockgeneratorMockRecorder is the mock recorder for Mockgenerator.
type MockgeneratorMockRecorder struct {
	mock *Mockgenerator
}

// NewMockgenerator creates a new mock instance.
func NewMockgenerator(ctrl *gomock.Controller) *Mockgenerator {
	mock := &Mockgenerator{ctrl: ctrl}
	mock.recorder = &MockgeneratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockgenerator) EXPECT() *MockgeneratorMockRecorder {
	return m.recorder
}

// Generate mocks base method.
func (m *Mockgenerator) Generate() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Generate")
	ret0, _ := ret[0].(string)
	return ret0
}

// Generate indicates an expected call of Generate.
func (mr *MockgeneratorMockRecorder) Generate() *generatorGenerateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Generate", reflect.TypeOf((*Mockgenerator)(nil).Generate))
	return &generatorGenerateCall{Call: call}
}

// generatorGenerateCall wrap *gomock.Call
type generatorGenerateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *generatorGenerateCall) Return(arg0 string) *generatorGenerateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *generatorGenerateCall) Do(f func() string) *generatorGenerateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *generatorGenerateCall) DoAndReturn(f func() string) *generatorGenerateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
