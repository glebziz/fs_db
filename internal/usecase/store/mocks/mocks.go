// Code generated by MockGen. DO NOT EDIT.
// Source: usecase.go
//
// Generated by this command:
//
//	mockgen -source usecase.go -destination mocks/mocks.go -typed true
//
// Package mock_store is a generated GoMock package.
package mock_store

import (
	context "context"
	model "github.com/glebziz/fs_db/internal/model"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockdirUsecase is a mock of dirUsecase interface.
type MockdirUsecase struct {
	ctrl     *gomock.Controller
	recorder *MockdirUsecaseMockRecorder
}

// MockdirUsecaseMockRecorder is the mock recorder for MockdirUsecase.
type MockdirUsecaseMockRecorder struct {
	mock *MockdirUsecase
}

// NewMockdirUsecase creates a new mock instance.
func NewMockdirUsecase(ctrl *gomock.Controller) *MockdirUsecase {
	mock := &MockdirUsecase{ctrl: ctrl}
	mock.recorder = &MockdirUsecaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockdirUsecase) EXPECT() *MockdirUsecaseMockRecorder {
	return m.recorder
}

// Select mocks base method.
func (m *MockdirUsecase) Select(ctx context.Context, size uint64) (*model.Dir, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Select", ctx, size)
	ret0, _ := ret[0].(*model.Dir)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Select indicates an expected call of Select.
func (mr *MockdirUsecaseMockRecorder) Select(ctx, size any) *dirUsecaseSelectCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Select", reflect.TypeOf((*MockdirUsecase)(nil).Select), ctx, size)
	return &dirUsecaseSelectCall{Call: call}
}

// dirUsecaseSelectCall wrap *gomock.Call
type dirUsecaseSelectCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *dirUsecaseSelectCall) Return(arg0 *model.Dir, arg1 error) *dirUsecaseSelectCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *dirUsecaseSelectCall) Do(f func(context.Context, uint64) (*model.Dir, error)) *dirUsecaseSelectCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *dirUsecaseSelectCall) DoAndReturn(f func(context.Context, uint64) (*model.Dir, error)) *dirUsecaseSelectCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockcontentRepository is a mock of contentRepository interface.
type MockcontentRepository struct {
	ctrl     *gomock.Controller
	recorder *MockcontentRepositoryMockRecorder
}

// MockcontentRepositoryMockRecorder is the mock recorder for MockcontentRepository.
type MockcontentRepositoryMockRecorder struct {
	mock *MockcontentRepository
}

// NewMockcontentRepository creates a new mock instance.
func NewMockcontentRepository(ctrl *gomock.Controller) *MockcontentRepository {
	mock := &MockcontentRepository{ctrl: ctrl}
	mock.recorder = &MockcontentRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockcontentRepository) EXPECT() *MockcontentRepositoryMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockcontentRepository) Delete(ctx context.Context, path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, path)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockcontentRepositoryMockRecorder) Delete(ctx, path any) *contentRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockcontentRepository)(nil).Delete), ctx, path)
	return &contentRepositoryDeleteCall{Call: call}
}

// contentRepositoryDeleteCall wrap *gomock.Call
type contentRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentRepositoryDeleteCall) Return(arg0 error) *contentRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentRepositoryDeleteCall) Do(f func(context.Context, string) error) *contentRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentRepositoryDeleteCall) DoAndReturn(f func(context.Context, string) error) *contentRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockcontentRepository) Get(ctx context.Context, path string) (*model.Content, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, path)
	ret0, _ := ret[0].(*model.Content)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockcontentRepositoryMockRecorder) Get(ctx, path any) *contentRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockcontentRepository)(nil).Get), ctx, path)
	return &contentRepositoryGetCall{Call: call}
}

// contentRepositoryGetCall wrap *gomock.Call
type contentRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentRepositoryGetCall) Return(arg0 *model.Content, arg1 error) *contentRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentRepositoryGetCall) Do(f func(context.Context, string) (*model.Content, error)) *contentRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentRepositoryGetCall) DoAndReturn(f func(context.Context, string) (*model.Content, error)) *contentRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockcontentRepository) Store(ctx context.Context, path string, content *model.Content) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, path, content)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockcontentRepositoryMockRecorder) Store(ctx, path, content any) *contentRepositoryStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockcontentRepository)(nil).Store), ctx, path, content)
	return &contentRepositoryStoreCall{Call: call}
}

// contentRepositoryStoreCall wrap *gomock.Call
type contentRepositoryStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *contentRepositoryStoreCall) Return(arg0 error) *contentRepositoryStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *contentRepositoryStoreCall) Do(f func(context.Context, string, *model.Content) error) *contentRepositoryStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *contentRepositoryStoreCall) DoAndReturn(f func(context.Context, string, *model.Content) error) *contentRepositoryStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// MockfileRepository is a mock of fileRepository interface.
type MockfileRepository struct {
	ctrl     *gomock.Controller
	recorder *MockfileRepositoryMockRecorder
}

// MockfileRepositoryMockRecorder is the mock recorder for MockfileRepository.
type MockfileRepositoryMockRecorder struct {
	mock *MockfileRepository
}

// NewMockfileRepository creates a new mock instance.
func NewMockfileRepository(ctrl *gomock.Controller) *MockfileRepository {
	mock := &MockfileRepository{ctrl: ctrl}
	mock.recorder = &MockfileRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockfileRepository) EXPECT() *MockfileRepositoryMockRecorder {
	return m.recorder
}

// Delete mocks base method.
func (m *MockfileRepository) Delete(ctx context.Context, key string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Delete", ctx, key)
	ret0, _ := ret[0].(error)
	return ret0
}

// Delete indicates an expected call of Delete.
func (mr *MockfileRepositoryMockRecorder) Delete(ctx, key any) *fileRepositoryDeleteCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Delete", reflect.TypeOf((*MockfileRepository)(nil).Delete), ctx, key)
	return &fileRepositoryDeleteCall{Call: call}
}

// fileRepositoryDeleteCall wrap *gomock.Call
type fileRepositoryDeleteCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryDeleteCall) Return(arg0 error) *fileRepositoryDeleteCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryDeleteCall) Do(f func(context.Context, string) error) *fileRepositoryDeleteCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryDeleteCall) DoAndReturn(f func(context.Context, string) error) *fileRepositoryDeleteCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Get mocks base method.
func (m *MockfileRepository) Get(ctx context.Context, key string) (*model.File, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Get", ctx, key)
	ret0, _ := ret[0].(*model.File)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Get indicates an expected call of Get.
func (mr *MockfileRepositoryMockRecorder) Get(ctx, key any) *fileRepositoryGetCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Get", reflect.TypeOf((*MockfileRepository)(nil).Get), ctx, key)
	return &fileRepositoryGetCall{Call: call}
}

// fileRepositoryGetCall wrap *gomock.Call
type fileRepositoryGetCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryGetCall) Return(arg0 *model.File, arg1 error) *fileRepositoryGetCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryGetCall) Do(f func(context.Context, string) (*model.File, error)) *fileRepositoryGetCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryGetCall) DoAndReturn(f func(context.Context, string) (*model.File, error)) *fileRepositoryGetCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Store mocks base method.
func (m *MockfileRepository) Store(ctx context.Context, file model.File) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Store", ctx, file)
	ret0, _ := ret[0].(error)
	return ret0
}

// Store indicates an expected call of Store.
func (mr *MockfileRepositoryMockRecorder) Store(ctx, file any) *fileRepositoryStoreCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Store", reflect.TypeOf((*MockfileRepository)(nil).Store), ctx, file)
	return &fileRepositoryStoreCall{Call: call}
}

// fileRepositoryStoreCall wrap *gomock.Call
type fileRepositoryStoreCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *fileRepositoryStoreCall) Return(arg0 error) *fileRepositoryStoreCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *fileRepositoryStoreCall) Do(f func(context.Context, model.File) error) *fileRepositoryStoreCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *fileRepositoryStoreCall) DoAndReturn(f func(context.Context, model.File) error) *fileRepositoryStoreCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// Mockgenerator is a mock of generator interface.
type Mockgenerator struct {
	ctrl     *gomock.Controller
	recorder *MockgeneratorMockRecorder
}

// MockgeneratorMockRecorder is the mock recorder for Mockgenerator.
type MockgeneratorMockRecorder struct {
	mock *Mockgenerator
}

// NewMockgenerator creates a new mock instance.
func NewMockgenerator(ctrl *gomock.Controller) *Mockgenerator {
	mock := &Mockgenerator{ctrl: ctrl}
	mock.recorder = &MockgeneratorMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *Mockgenerator) EXPECT() *MockgeneratorMockRecorder {
	return m.recorder
}

// Generate mocks base method.
func (m *Mockgenerator) Generate() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Generate")
	ret0, _ := ret[0].(string)
	return ret0
}

// Generate indicates an expected call of Generate.
func (mr *MockgeneratorMockRecorder) Generate() *generatorGenerateCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Generate", reflect.TypeOf((*Mockgenerator)(nil).Generate))
	return &generatorGenerateCall{Call: call}
}

// generatorGenerateCall wrap *gomock.Call
type generatorGenerateCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *generatorGenerateCall) Return(arg0 string) *generatorGenerateCall {
	c.Call = c.Call.Return(arg0)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *generatorGenerateCall) Do(f func() string) *generatorGenerateCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *generatorGenerateCall) DoAndReturn(f func() string) *generatorGenerateCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
